head	1.44;
access;
symbols;
locks; strict;
comment	@# @;


1.44
date	2026.02.09.12.12.11;	author u0_a108;	state Exp;
branches;
next	1.43;
commitid	1006989CF1B264554B5;

1.43
date	2026.01.26.13.17.39;	author u0_a108;	state Exp;
branches;
next	1.42;
commitid	1006977697267F52933;

1.42
date	2026.01.24.08.06.42;	author u0_a108;	state Exp;
branches;
next	1.41;
commitid	10069747D923B0DF4B6;

1.41
date	2026.01.24.06.48.44;	author u0_a108;	state Exp;
branches;
next	1.40;
commitid	10069746B4C361D8EC0;

1.40
date	2026.01.24.04.33.48;	author u0_a108;	state Exp;
branches;
next	1.39;
commitid	10069744BAC2E43E00E;

1.39
date	2026.01.22.16.55.17;	author u0_a108;	state Exp;
branches;
next	1.38;
commitid	100697256753B2BF8F3;

1.38
date	2026.01.21.16.22.04;	author u0_a108;	state Exp;
branches;
next	1.37;
commitid	1006970FD2C6B219F32;

1.37
date	2026.01.10.15.12.15;	author u0_a108;	state Exp;
branches;
next	1.36;
commitid	10069626C4F62A62920;

1.36
date	2026.01.07.15.29.12;	author u0_a108;	state Exp;
branches;
next	1.35;
commitid	100695E7BC8212644DB;

1.35
date	2026.01.07.04.13.18;	author u0_a108;	state Exp;
branches;
next	1.34;
commitid	100695DDD5E0EB047F1;

1.34
date	2026.01.07.00.20.13;	author u0_a270;	state Exp;
branches;
next	1.33;
commitid	100695DA6BD69DC6EA8;

1.33
date	2025.07.11.16.17.42;	author u0_a157;	state Exp;
branches;
next	1.32;
commitid	1006871392657713F9E;

1.32
date	2025.07.11.15.20.58;	author u0_a157;	state Exp;
branches;
next	1.31;
commitid	10068712BDA4ED50F15;

1.31
date	2025.06.09.15.04.56;	author u0_a157;	state Exp;
branches;
next	1.30;
commitid	1006846F8181E6AC30A;

1.30
date	2025.05.18.16.09.19;	author u0_a157;	state Exp;
branches;
next	1.29;
commitid	100682A062F1372839F;

1.29
date	2025.05.14.15.33.11;	author u0_a157;	state Exp;
branches;
next	1.28;
commitid	1006824B7B76DCB3E43;

1.28
date	2022.07.28.16.46.34;	author android;	state Exp;
branches;
next	1.27;
commitid	10062E2BD6A0286A635;

1.27
date	2022.07.26.17.28.20;	author android;	state Exp;
branches;
next	1.26;
commitid	10062E02434088DC038;

1.26
date	2022.07.05.16.37.13;	author android;	state Exp;
branches;
next	1.25;
commitid	10062C468B91EE47B50;

1.25
date	2022.06.06.13.41.12;	author android;	state Exp;
branches;
next	1.24;
commitid	100629E03F81EB80EF8;

1.24
date	2022.04.04.11.34.06;	author android;	state Exp;
branches;
next	1.23;
commitid	100624AD7AE137AC783;

1.23
date	2022.03.20.11.16.40;	author android;	state Exp;
branches;
next	1.22;
commitid	10062370D1874A608A2;

1.22
date	2022.03.18.16.17.01;	author android;	state Exp;
branches;
next	1.21;
commitid	1006234B07D3700DDAF;

1.21
date	2022.03.07.14.58.00;	author android;	state Exp;
branches;
next	1.20;
commitid	10062261D7830B3AE3B;

1.20
date	2022.02.22.14.13.16;	author android;	state Exp;
branches;
next	1.19;
commitid	1006214EF7C04969FD3;

1.19
date	2022.02.08.09.16.46;	author android;	state Exp;
branches;
next	1.18;
commitid	100620234FE55B3ABE5;

1.18
date	2021.10.30.10.18.02;	author android;	state Exp;
branches;
next	1.17;
commitid	9lxzCw7RYnVqWOeD;

1.17
date	2021.09.25.04.53.56;	author android;	state Exp;
branches;
next	1.16;
commitid	csGUGfCgPIZZgiaD;

1.16
date	2021.09.17.16.34.45;	author android;	state Exp;
branches;
next	1.15;
commitid	tkkEBXUXrTzmpk9D;

1.15
date	2021.09.17.16.12.20;	author android;	state Exp;
branches;
next	1.14;
commitid	wU54a7aHLMXFhk9D;

1.14
date	2021.09.17.15.51.58;	author android;	state Exp;
branches;
next	1.13;
commitid	rd4foXhA7lvGak9D;

1.13
date	2021.09.17.15.19.48;	author android;	state Exp;
branches;
next	1.12;
commitid	Jy2JqguJNpqEZj9D;

1.12
date	2021.09.12.15.23.30;	author android;	state Exp;
branches;
next	1.11;
commitid	ExYhO3PzebPSaG8D;

1.11
date	2021.09.12.15.09.51;	author android;	state Exp;
branches;
next	1.10;
commitid	wrV4FysAO5vc6G8D;

1.10
date	2021.09.08.15.26.20;	author android;	state Exp;
branches;
next	1.9;
commitid	xkpjixQ4bqkPja8D;

1.9
date	2021.09.08.14.48.10;	author android;	state Exp;
branches;
next	1.8;
commitid	4VCL8ja3L5NJ6a8D;

1.8
date	2021.09.08.01.36.31;	author android;	state Exp;
branches;
next	1.7;
commitid	s65mgFPiYQw9J58D;

1.7
date	2021.09.08.01.05.12;	author android;	state Exp;
branches;
next	1.6;
commitid	31n1AnHmuCjpy58D;

1.6
date	2021.08.29.03.27.49;	author android;	state Exp;
branches;
next	1.5;
commitid	WAUcMhXW9tdgFO6D;

1.5
date	2021.08.01.12.38.06;	author android;	state Exp;
branches;
next	1.4;
commitid	ZJVCq3GDEHwQBg3D;

1.4
date	2021.08.01.02.58.25;	author android;	state Exp;
branches;
next	1.3;
commitid	Oo5O4NJW82UYod3D;

1.3
date	2021.07.06.14.36.32;	author android;	state Exp;
branches;
next	1.2;
commitid	fs1KbbCnPrTh6WZC;

1.2
date	2021.06.20.08.03.33;	author android;	state Exp;
branches;
next	1.1;
commitid	OCQK5lIh49bmrQXC;

1.1
date	2021.06.20.07.29.14;	author android;	state Exp;
branches;
next	;
commitid	Ib9ovegQE2iAfQXC;


desc
@@


1.44
log
@fix: write before swithc to term
@
text
@" vim: set sw=4 ts=4 sts=4 et tw=78 foldmarker={,} foldlevel=1 foldmethod=marker :
let s:syndic = {'python':'python3', 'sh':'bash', 'lua':'pb lu', 'scheme':'pb li', 'javascript':'qjs'}
let s:term_height = 10
let s:hint_height = 5

" ScriptRunTool {
" Check QuickFix 1-open/0-close
function! s:checkQuickfix()
  let l:hasqf = 0
  for winnr in range(1, winnr('$'))
    if getwinvar(winnr, '&syntax') == 'qf'
      let l:hasqf = 1
      break
    endif
  endfor
  return l:hasqf
endfunction

" default show quickfix window. silent run if has more argument
function! s:runcmd(cmd, ...)
  execute 'Shell '.a:cmd
  if a:0==0 && !s:checkQuickfix()
      "execute 'copen'
  endif
endfunction

function! s:chooseExecutor()
  let l:ft = &filetype
  let l:cmd = ''
  for [k, v] in items(s:syndic)
      if k ==? l:ft
          let l:cmd = v | break
      endif
  endfor
  if '' == l:cmd
      let l:cmd = input('cannot recognize this filetype, choose executor: ')
      let s:syndic[&filetype] = l:cmd
  endif
  return l:cmd
endfunction

function! rv#changerunscript(cmd)
  if '' == a:cmd
      echo s:syndic[&filetype]
  else
      let s:syndic[&filetype] = a:cmd
  endif
endfunction

" open new term and return buf number
function! s:newterm(executable)
  if has('nvim')
    new
    call termopen(a:executable)
    " termopen return jobid instead of buf_number, find it ugly
    let l:last_buf = bufnr('$')
    let l:i = 1
    while l:i <= l:last_buf
        if getbufvar(l:i, "&bt") == "terminal"
            let l:termbuf_id = l:i
            break
        endif
        let l:i = l:i + 1
    endwhile
  else
    let l:termbuf_id = term_start(a:executable)
  endif
  return l:termbuf_id
endfunction

" first time, create a repl. after that toggle or close
function! rv#replConnect(vm)
  let l:scheme_executable = a:vm
  if '' == l:scheme_executable
    let l:scheme_executable = s:chooseExecutor()
  endif
  if '' == l:scheme_executable
    return
  endif

  if !exists('s:repl_term_id') || ''==bufname(s:repl_term_id)
    let s:repl_term_id = s:newterm(l:scheme_executable)
    silent execute "resize " . s:term_height
    normal! G
  else
    let l:wid = bufwinnr(s:repl_term_id)
    if l:wid < 0
      exec "rightbelow ".s:term_height."split"
      exec "b".s:repl_term_id
    else
      exec l:wid."wincmd w"
      close
    endif
  endif
endfunction

" run part code in another window by cp<textobj>
function! rv#replEval(type)
  let sel_save = &selection
  let &selection = "inclusive"
  let reg_save = @@@@

  if a:0
    silent exe "normal! `<" . a:type . "`>y"
  elseif a:type == 'line'
    silent exe "normal! '[V']y"
  elseif a:type == 'block'
    silent exe "normal! `[\<C-V>`]y"
  else
    silent exe "normal! `[v`]y"
  endif

  if !exists('s:repl_term_id')
    call rv#replConnect('')
  end

  if has("nvim")
    call jobsend(s:repl_term_id, @@@@ . "\n")
  else
    call term_sendkeys(s:repl_term_id, @@@@ . "\n")
  end

  let &selection = sel_save
  let @@@@ = reg_save
endfunction

function! rv#runcurrentscript(hasarg)
  let l:cmd = s:chooseExecutor()
  if '' == l:cmd
      return
  endif
  let l:arg = ''
  if a:hasarg
    let l:arg = input('Arguments: ')
  endif
  execute 'write'
  call <SID>runcmd(l:cmd.' % '.l:arg)
endfunction

let s:term_flag = 0
function rv#term_reuse()
  if &modified
    silent! write
  endif
  if s:term_flag == 0
    if has('nvim')
      split
      terminal
      startinsert
    else
      terminal
    endif
    let s:term_flag = bufnr()
  else
    let tm_h = winheight(winnr())/3
    split
    execute 'resize '.tm_h
    execute 'b'.s:term_flag
    if has('nvim')
      startinsert
    else
      normal! i
    endif
  endif
endfunction

function! rv#runShellCommand(cmdline)
    silent execute "botright ".s:term_height."new"

    setlocal buftype=nofile
    setlocal bufhidden=delete
    setlocal nobuflisted
    setlocal noswapfile
    setlocal nowrap
    setlocal filetype=shell
    setlocal syntax=shell

    call setline(1, a:cmdline)
    call setline(2, substitute(a:cmdline, '.', '=', 'g'))
    execute 'silent $read !' . escape(a:cmdline, '%#')
    setlocal nomodifiable
    1
endfunction

function! s:cqfrg(cw)
  execute "silent! grep! ".shellescape(a:cw)." *"
  cwindow
  normal 
endfunction

function! rv#enhancegrep(useinput)
  let l:word = expand("<cword>")
  if type(a:useinput) == 1 "str
      let l:word = a:useinput
  elseif a:useinput == 1
      let l:word = input("Keyword: ", l:word)
  endif
  if executable('rg')
      set grepprg=rg\ --vimgrep\ --color=never
      call s:cqfrg(l:word)
  else
      set grepprg=grep\ -RIin\ --color=never
      call s:cqfrg(l:word)
  endif
endfunction

" c-confirm    g-direct
function! rv#txtReplace(flag)
  let pat = input("Patern:")
  let tar = input("Target:")
  execute "%s/".pat."/".tar."/".a:flag
endfunction

function! rv#bufferchoose()
  ls
  let l:bc = input("choose buffer:")
  if l:bc =~# '^\d\+$'
    execute 'buffer' l:bc
  else
    let l:pat = join(split(l:bc, '\zs'), '.*')
    let l:bfl = getbufinfo({'buflisted':1})
    for v in l:bfl
      if match(bufname(v.bufnr), l:pat) >= 0
        execute 'buffer' v.bufnr
        return
      endif
    endfor
    echo " Not found"
  endif
endfunction

function rv#simplemove(fb)
  let pos = input('jump(hl): ')
  let tow = matchlist(pos, '\v(\d+)([hl]?)$')
  let cur = getpos('.')
  let cur[1] += a:fb * str2nr(tow[1])
  if tow[2] == 'h'
    let cur[2] = 1
  elseif tow[2] == 'l'
    let cur[2] = len(getline(cur[1]))
  else
    let cur[2] = float2nr(len(getline(cur[1]))/2)
  endif
  call setpos('.', cur)
endfunction

" execute command another window and cursor stay
function! rv#openpreview(cmd)
  let cur_winid = winnr()
  if !exists('s:hint_buf_id')
    silent execute "botright ".s:hint_height."new"
    setlocal buftype=nofile
    setlocal nobuflisted
    let s:hint_buf_id = winbufnr(0)
  else
    let l:wid = bufwinnr(s:hint_buf_id)
    if l:wid < 0
      exec "rightbelow ".s:hint_height."split"
      exec "b".s:hint_buf_id
    else
      exec l:wid."wincmd w"
    endif
  endif
  " collect output of command and paste
  %d
  let out_cmd = system(a:cmd)
  put=l:out_cmd
  normal ggdd
  " Final goback orig window
  exec l:cur_winid."wincmd w"
endfunction

function! rv#closepreview()
  let l:wid = bufwinnr(s:hint_buf_id)
  if l:wid >= 0
    exec l:wid."wincmd w"
    close
  endif
endfunction

function! rv#showhint()
  let l:kw = input('HintWord: ')
  if l:kw != ''
    let l:ft = &filetype
    call rv#openpreview("snip ".l:ft." lib|grep ".l:kw)
  else
    call rv#closepreview()
  endif
endfunction
" }

" Toggle {
function! rv#togglequickfix()
  if s:checkQuickfix()
      execute 'cclose'
  else
      execute 'copen'
  endif
endfunction

function! rv#toggleBG()
    let l:tbg = &background
    " Inversion
    if l:tbg == "dark"
        set background=light
    else
        set background=dark
    endif
endfunction

" Change between relativenumber and nonumber
function! rv#toggleNumber()
    let l:tbg = &relativenumber
    " Inversion
    if l:tbg == 1
        set norelativenumber
        set nonumber
    else
        set number
        set relativenumber
    endif
endfunction
" }

function rv#mksess(nam)
  execute 'mksession! '.g:mvcf_path.a:nam.'_sess.vim'
endfunction

function rv#ldsess(nam)
  execute 'source '.g:mvcf_path.a:nam.'_sess.vim'
endfunction

" Find top dir and refresh tags {
function! rv#gototopdir()
   let i = 1
   while i < 10
      if filereadable("tags") || isdirectory(".git")
        echo "Found top dir"
        return
      else
        lcd ..
        let i += 1
      endif
   endwhile
endfunction

function! rv#refreshtags()
   wall
   let l:Curr_dir=getcwd()
   let i = 1
   while i < 10
      if filereadable("tags")
        call <SID>runcmd('ctags -R', 'silent')
        "--fields=+lS  cscope -Rbkq
        return
      else
        lcd ..
        let i += 1
      endif
   endwhile
   exec 'cd '.l:Curr_dir
   "force buffer reload tags
   edit %
endfunction
" }

" Easy show {
function! rv#showMaps()
  let old_reg = getreg("a")          " save the current content of register a
  let old_reg_type = getregtype("a") " save the type of the register as well
try
  redir @@a                           " redirect output to register a
  " Get the list of all key mappings silently, satisfy "Press ENTER to continue"
  silent map  | call feedkeys("\<CR>")
  silent imap | call feedkeys("\<CR>")
  redir END                          " end output redirection
  vnew                               " new buffer in vertical window
  setlocal buftype=nofile
  setlocal bufhidden=delete
  setlocal nobuflisted
  setlocal noswapfile
  setlocal nowrap
  put a                              " put content of register
  " Sort on 4th character column which is the key(s)
  %!sort -k1.4,1.4
finally                              " Execute even if exception is raised
  call setreg("a", old_reg, old_reg_type) " restore register a
endtry
endfunction

function! rv#showEx(cmd)
  redir => message
  silent execute a:cmd
  redir END
  if empty(message)
    echoerr "no output"
  else
    " use "new" instead of "tabnew" below if you prefer split windows instead of tabs
    new
    setlocal buftype=nofile bufhidden=wipe noswapfile nobuflisted nomodified
    silent put=message
  endif
endfunction

" Snip in normal and insert mode
function! rv#showsnipcode()
    let l:ft = &filetype
    let l:arg = input('SnipKey: ')
    call rv#runShellCommand('snip '.l:ft.' '.l:arg)
endfunction

function! rv#inssnipcode()
  let l:a = input("SnipKey: ")
  if "" == l:a
    echo &filetype." support:"
    let l:ret = system('snip ! '.&filetype)
    echo split(l:ret, "\n")
    return
  endif
  "mark and paste, back and join line
  normal mq
  execute "put =system('snip ! ".&filetype." ".l:a."')"
  normal 'qJ
  "call feedkeys("i")
  "return ''
endfunction

function! rv#openfileinwin1()
  let pth = expand('<cfile>')
  1wincmd w
  execute 'e./'.pth
endfunction

" Simple bracket pair match
function! s:findopenbracket(cur)
  let cnt = 0
  let [line, col] = [line('.'), col('.')]

  let w_times = 0
  while w_times < 1000
    let char = getline(line)[col - 1]
    if char == ')' || char == ']' || char == '}'
      let cnt += 1
    elseif char == '(' || char == '[' || char == '{'
      let cnt -= 1
    endif

    " return when find lonely open bracket
    if cnt < 0
      call cursor(line, col)
      return [0, line, col, 0]
    endif

    " 移动到前一个字符
    if col > 1
      let col -= 1
    else
      if line == 1
        echoerr 'Not found open bracket'
      endif
      let line -= 1
      let col = strlen(getline(line))
    endif
    let w_times += 1
  endwhile
  return a:cur
endfunction

function! rv#selectParens(vt, ai) abort
    let save_pos = getpos('.')
    "if search('(', 'bW') == 0 echo "No opening paren found"
    let start_pos = s:findopenbracket(save_pos)
    normal! %
    let end_pos = getpos('.')

    call setpos('.', save_pos)
    normal! gv
    if a:ai == 'i'
      let start_pos[2] += 1
      if end_pos[2] == 1
        " move to preview line last col
        let end_pos[1] -= 1
        let end_pos[2] = len(getline(end_pos[1]))
      else
        let end_pos[2] -= 1
      endif
    endif
    call setpos("'<", start_pos)
    call setpos("'>", end_pos)
    normal! gv
endfunction

function! rv#expandTag()
  let word = expand('<cword>')
  let void_elem = ['br', 'hr', 'img', 'input']
  if index(void_elem, word) >= 0
    let html = "<" . word . ">"
  else
    let html = "<" . word . "></" . word . ">"
  endif
  execute "normal! ciw" . html . "\<Esc>"
  if index(void_elem, word) < 0
    normal! F<
    startinsert
  endif
endfunction

" When not know what happen under vim, use this
function! rv#debug(...)
  let tname = ['int', 'str', 'fn', 'list', 'dict', 'bool', 'none', 'job', 'ch', 'blob']
  let logfile = 'rvdebug.log'
  "let l:cmd = printf("echo '>> stack:%s'>>%s", expand('<stack>'), logfile)
  "call system(l:cmd)
  let i = 1
  for v in a:000
    let l:nam = tname[type(v)]
    let l:cmd = printf("echo '>> arg%d:%s:%s'>>%s", i, l:nam, v, logfile)
    call system(l:cmd)
    let i = i+1
  endfor
endfunction
" }

@


1.43
log
@feat: mb/mf and kk trigger terminal
@
text
@d142 3
@


1.42
log
@feat: fake simplemove instead of easymotion
@
text
@d140 24
d230 1
a230 1
  let pos = input('jump: ')
@


1.41
log
@fix: move easymotion to switch
@
text
@d205 15
@


1.40
log
@fix: avoid find bracket endless loop
@
text
@d438 7
a444 1
      let end_pos[2] -= 1
@


1.39
log
@feat: let selectParens as textobject
@
text
@d393 1
a393 1
function! s:findopenbracket()
d397 2
a398 1
  while 1
d422 1
d424 1
d430 1
a430 1
    let start_pos = s:findopenbracket()
@


1.38
log
@feat: cmd Psave and Pload
@
text
@d424 1
a424 1
function! rv#selectParens() abort
d427 1
a427 1
    let start_pos = <SID>findopenbracket()
d432 5
@


1.37
log
@fix: <leader>gp has default input
@
text
@d283 8
@


1.36
log
@feat: choose buffer friendly
@
text
@d166 1
a166 1
  if type(a:useinput) == 1
d169 1
a169 1
      let l:word = input("Keyword:")
@


1.35
log
@fix: CheckQuickfix rename s:
@
text
@d187 18
@


1.34
log
@fix: grep use qf
@
text
@d7 11
d22 1
a22 1
  if a:0==0 && !MvcfCheckQuickfix()
d234 1
a234 1
  if MvcfCheckQuickfix()
@


1.33
log
@feat: simple emmet
@
text
@d147 6
d161 2
a162 5
      call <SID>runcmd('rg "'.l:word.'"')
  elseif executable('ag')
      call <SID>runcmd('ag "'.l:word.'"')
  elseif executable('ack')
      call <SID>runcmd('ack "'.l:word.'"')
d164 2
a165 1
      call <SID>runcmd('grep -in -R "'.l:word.'" *')
@


1.32
log
@fix: remove vim-sexp because I rewrite a simple version
@
text
@d396 15
@


1.31
log
@feat: rv selectParens
@
text
@d2 1
a2 1
let s:syndic = {'python':'python3', 'sh':'bash', 'lua':'lua', 'scheme':'fennel', 'javascript':'qjs'}
@


1.30
log
@doc: vim rv
@
text
@d351 45
@


1.29
log
@doc: vim rv.txt
@
text
@d10 3
a12 8
  if has('nvim') || v:version < 800
      execute 'Shell '.a:cmd
  else
      execute 'Shell '.a:cmd
      if a:0==0 && !MvcfCheckQuickfix()
          "execute 'copen'
          echo 1
      endif
@


1.28
log
@show snip lib in faker preview window
@
text
@d13 1
a13 1
      execute 'AsyncRun '.a:cmd
d15 2
a16 1
          execute 'copen'
d166 1
a166 1
      call <SID>runcmd('grep -i -R "'.l:word.'" *')
@


1.27
log
@add preview like shell in vim
@
text
@d176 2
a177 1
function! rv#openhint(kw)
d195 1
a195 1
  let out_cmd = system(a:kw)
d202 1
a202 1
function! rv#closehint()
d209 10
@


1.26
log
@simple replace for vim
@
text
@d4 1
d175 33
@


1.25
log
@change scm engine to fennel and add Chrun doc
@
text
@d168 6
@


1.24
log
@adapt typename in nvim
@
text
@a0 1
" Modeline and Notes {
d2 1
a2 2
" }
let s:syndic = {'python':'python3', 'sh':'bash', 'lua':'lua', 'scheme':'stklos', 'lisp':'ecl'}
@


1.23
log
@use beauty method to choose terminal buf in nvim
@
text
@d308 1
d314 2
a315 1
    let l:cmd = printf("echo '>> arg%d:%s:%s'>>%s", i, type(v), v, logfile)
@


1.22
log
@make newterm work in nvim
@
text
@d53 1
a53 1
        if match(bufname(l:i), "term://") == 0
@


1.21
log
@seems nvim not work with AsyncRun, workaround it
@
text
@d44 1
d48 11
a58 1
    let l:term_id = termopen(a:executable)
d60 1
a60 1
    let l:term_id = term_start(a:executable)
d62 1
a62 1
  return l:term_id
d309 2
a310 2
  let cmd = printf("echo '>> stack:%s'>>%s", expand('<stack>'), logfile)
  call system(l:cmd)
d313 1
a313 1
    let cmd = printf("echo '>> arg%d:%s:%s'>>%s", i, typename(v), v, logfile)
@


1.20
log
@rv#debug output to file
@
text
@d11 3
a13 1
  if v:version >= 800
a17 2
  else
      execute 'Shell '.a:cmd
@


1.19
log
@improve vim rv#debug use echom
@
text
@d297 3
a299 1
  echom printf('>> stack:%s', expand('<stack>'))
d302 2
a303 1
    echom printf('>> arg%d:%s:%s', i, typename(v), v)
a305 3
  if input("press enter to continue") == "dummy"
      echo ''
  endif
@


1.18
log
@improve insert snip
@
text
@d235 1
a235 1
  silent map | call feedkeys("\<CR>")
d297 9
a305 9
    if winnr('$') == 1
        top new
        setlocal buftype=nofile
        setlocal bufhidden=delete
        setlocal nobuflisted
        setlocal noswapfile
    endif
    1wincmd w
    put=a:000
@


1.17
log
@add insert snipcode
@
text
@d281 2
d284 1
@


1.16
log
@make rv.vim uint and clear
@
text
@d266 1
d269 1
a269 1
    let l:arg = input('Keyword: ')
d273 13
@


1.15
log
@add Chrun command show and change runscript
@
text
@a79 1

d110 8
a117 28
function! rv#showMaps()
  let old_reg = getreg("a")          " save the current content of register a
  let old_reg_type = getregtype("a") " save the type of the register as well
try
  redir @@a                           " redirect output to register a
  " Get the list of all key mappings silently, satisfy "Press ENTER to continue"
  silent map | call feedkeys("\<CR>")
  silent imap | call feedkeys("\<CR>")
  redir END                          " end output redirection
  vnew                               " new buffer in vertical window
  setlocal buftype=nofile
  setlocal bufhidden=delete
  setlocal nobuflisted
  setlocal noswapfile
  setlocal nowrap
  put a                              " put content of register
  " Sort on 4th character column which is the key(s)
  %!sort -k1.4,1.4
finally                              " Execute even if exception is raised
  call setreg("a", old_reg, old_reg_type) " restore register a
endtry
endfunction

function! rv#togglequickfix()
  if MvcfCheckQuickfix()
      execute 'cclose'
  else
      execute 'copen'
d119 2
d141 27
a167 4
function! rv#showsnipcode()
    let l:ft = &filetype
    let l:arg = input('Keyword: ')
    call rv#runShellCommand('snip '.l:ft.' '.l:arg)
d192 15
a207 1
" refreshtags at top dir
d226 1
d228 22
a249 50
function! rv#runcurrentscript(hasarg)
  let l:cmd = s:chooseExecutor()
  if '' == l:cmd
      return
  endif
  let l:arg = ''
  if a:hasarg
    let l:arg = input('Arguments: ')
  endif
  execute 'write'
  call <SID>runcmd(l:cmd.' % '.l:arg)
endfunction

function! rv#openfileinwin1()
  let pth = expand('<cfile>')
  1wincmd w
  execute 'e./'.pth
endfunction

" Search-File-Keyword {
function! rv#enhancegrep(useinput)
  let l:word = expand("<cword>")
  if type(a:useinput) == 1
      let l:word = a:useinput
  elseif a:useinput == 1
      let l:word = input("Keyword:")
  endif
  if executable('rg')
      call <SID>runcmd('rg "'.l:word.'"')
  elseif executable('ag')
      call <SID>runcmd('ag "'.l:word.'"')
  elseif executable('ack')
      call <SID>runcmd('ack "'.l:word.'"')
  else
      call <SID>runcmd('grep -i -R "'.l:word.'" *')
  endif
endfunction

" find top dir
function! rv#gototopdir()
   let i = 1
   while i < 10
      if filereadable("tags") || isdirectory(".git")
        echo "Found top dir"
        return
      else
        lcd ..
        let i += 1
      endif
   endwhile
d266 12
a289 1

@


1.14
log
@make choose executor also avalble in repl
@
text
@d36 8
@


1.13
log
@add executor when filetype not recognize
@
text
@d29 4
d204 1
a204 2
      let l:cmd = input('cannot recognize this filetype, choose executor: ')
      let s:syndic[&filetype] = l:cmd
@


1.12
log
@fix cant open terminal when last time closed
@
text
@d200 2
a201 2
      echo 'runscript cannot recognize this filetype!'
      return
@


1.11
log
@enrich replConnect has create/open/close
@
text
@d52 1
a52 1
  if !exists('s:repl_term_id')
@


1.10
log
@use replConnect instead of vim-terminal-help
@
text
@d32 11
d52 13
a64 5
  if has('nvim')
    new
    let s:repl_term_id = termopen(l:scheme_executable)
  else
    let s:repl_term_id = term_start(l:scheme_executable)
a65 4

  silent execute "resize " . s:term_height

  normal! G
@


1.9
log
@minor improve config for vim
@
text
@d32 1
a32 1
function! s:replConnect(vm)
a52 1
command! -nargs=+ Repl call s:replConnect(<q-args>)
d71 1
a71 1
    call s:replConnect('')
@


1.8
log
@fixed bug:call replConnect miss let
@
text
@d2 1
a2 1
" vim: set sw=4 ts=4 sts=4 et tw=78 foldmarker={,} foldlevel=0 foldmethod=marker :
d5 1
d48 1
a48 4
  let g:scheme_split_size = get(g:, "scheme_split_size", "default")
  if g:scheme_split_size != "default"
    silent execute "resize " . g:scheme_split_size
  endif
d117 1
a117 1
    botright 10new
@


1.7
log
@let repl has parameter for specify
@
text
@d34 1
a34 1
    l:scheme_executable = s:chooseExecutor()
d55 1
a55 4
function! VMRun()
    let l:arg = input('Keyword: ')
    call s:replConnect(l:arg)
endfunction
@


1.6
log
@make Shell cmd 10height
@
text
@d31 2
a32 2
function! s:replConnect()
  let l:scheme_executable = s:chooseExecutor()
d34 4
a37 1
      return
d55 5
d77 1
a77 1
    call s:replConnect()
@


1.5
log
@restore sh execute in vim
@
text
@d114 1
a114 1
    botright new
@


1.4
log
@fix scheme cant use cp to compile
@
text
@d4 1
a4 1
let s:syndic = {'python':'python3', 'lua':'lua', 'scheme':'stklos', 'lisp':'ecl'}
@


1.3
log
@add vim debug function
@
text
@d4 1
a4 2
let s:syndic = {'python':'python3', 'sh':'bash', 'lua':'lua', 'scheme':'stklos', 'lisp':'ecl'}
autocmd FileType scheme,lisp,lua,python nnoremap <buffer> cp :set opfunc=<SID>replEval<cr>g@@
d53 1
a53 1
function! s:replEval(type)
@


1.2
log
@add showEx cmd for capture output of ex-mode
@
text
@d247 14
@


1.1
log
@use autoload instead of plugin
@
text
@d233 14
@

