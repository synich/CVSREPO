head	1.28;
access;
symbols;
locks; strict;
comment	@# @;


1.28
date	2022.07.28.16.46.34;	author android;	state Exp;
branches;
next	1.27;
commitid	10062E2BD6A0286A635;

1.27
date	2022.07.26.17.28.20;	author android;	state Exp;
branches;
next	1.26;
commitid	10062E02434088DC038;

1.26
date	2022.07.05.16.37.13;	author android;	state Exp;
branches;
next	1.25;
commitid	10062C468B91EE47B50;

1.25
date	2022.06.06.13.41.12;	author android;	state Exp;
branches;
next	1.24;
commitid	100629E03F81EB80EF8;

1.24
date	2022.04.04.11.34.06;	author android;	state Exp;
branches;
next	1.23;
commitid	100624AD7AE137AC783;

1.23
date	2022.03.20.11.16.40;	author android;	state Exp;
branches;
next	1.22;
commitid	10062370D1874A608A2;

1.22
date	2022.03.18.16.17.01;	author android;	state Exp;
branches;
next	1.21;
commitid	1006234B07D3700DDAF;

1.21
date	2022.03.07.14.58.00;	author android;	state Exp;
branches;
next	1.20;
commitid	10062261D7830B3AE3B;

1.20
date	2022.02.22.14.13.16;	author android;	state Exp;
branches;
next	1.19;
commitid	1006214EF7C04969FD3;

1.19
date	2022.02.08.09.16.46;	author android;	state Exp;
branches;
next	1.18;
commitid	100620234FE55B3ABE5;

1.18
date	2021.10.30.10.18.02;	author android;	state Exp;
branches;
next	1.17;
commitid	9lxzCw7RYnVqWOeD;

1.17
date	2021.09.25.04.53.56;	author android;	state Exp;
branches;
next	1.16;
commitid	csGUGfCgPIZZgiaD;

1.16
date	2021.09.17.16.34.45;	author android;	state Exp;
branches;
next	1.15;
commitid	tkkEBXUXrTzmpk9D;

1.15
date	2021.09.17.16.12.20;	author android;	state Exp;
branches;
next	1.14;
commitid	wU54a7aHLMXFhk9D;

1.14
date	2021.09.17.15.51.58;	author android;	state Exp;
branches;
next	1.13;
commitid	rd4foXhA7lvGak9D;

1.13
date	2021.09.17.15.19.48;	author android;	state Exp;
branches;
next	1.12;
commitid	Jy2JqguJNpqEZj9D;

1.12
date	2021.09.12.15.23.30;	author android;	state Exp;
branches;
next	1.11;
commitid	ExYhO3PzebPSaG8D;

1.11
date	2021.09.12.15.09.51;	author android;	state Exp;
branches;
next	1.10;
commitid	wrV4FysAO5vc6G8D;

1.10
date	2021.09.08.15.26.20;	author android;	state Exp;
branches;
next	1.9;
commitid	xkpjixQ4bqkPja8D;

1.9
date	2021.09.08.14.48.10;	author android;	state Exp;
branches;
next	1.8;
commitid	4VCL8ja3L5NJ6a8D;

1.8
date	2021.09.08.01.36.31;	author android;	state Exp;
branches;
next	1.7;
commitid	s65mgFPiYQw9J58D;

1.7
date	2021.09.08.01.05.12;	author android;	state Exp;
branches;
next	1.6;
commitid	31n1AnHmuCjpy58D;

1.6
date	2021.08.29.03.27.49;	author android;	state Exp;
branches;
next	1.5;
commitid	WAUcMhXW9tdgFO6D;

1.5
date	2021.08.01.12.38.06;	author android;	state Exp;
branches;
next	1.4;
commitid	ZJVCq3GDEHwQBg3D;

1.4
date	2021.08.01.02.58.25;	author android;	state Exp;
branches;
next	1.3;
commitid	Oo5O4NJW82UYod3D;

1.3
date	2021.07.06.14.36.32;	author android;	state Exp;
branches;
next	1.2;
commitid	fs1KbbCnPrTh6WZC;

1.2
date	2021.06.20.08.03.33;	author android;	state Exp;
branches;
next	1.1;
commitid	OCQK5lIh49bmrQXC;

1.1
date	2021.06.20.07.29.14;	author android;	state Exp;
branches;
next	;
commitid	Ib9ovegQE2iAfQXC;


desc
@@


1.28
log
@show snip lib in faker preview window
@
text
@" vim: set sw=4 ts=4 sts=4 et tw=78 foldmarker={,} foldlevel=1 foldmethod=marker :
let s:syndic = {'python':'python3', 'sh':'bash', 'lua':'lua', 'scheme':'fennel', 'javascript':'qjs'}
let s:term_height = 10
let s:hint_height = 5

" ScriptRunTool {

" default show quickfix window. silent run if has more argument
function! s:runcmd(cmd, ...)
  if has('nvim') || v:version < 800
      execute 'Shell '.a:cmd
  else
      execute 'AsyncRun '.a:cmd
      if a:0==0 && !MvcfCheckQuickfix()
          execute 'copen'
      endif
  endif
endfunction

function! s:chooseExecutor()
  let l:ft = &filetype
  let l:cmd = ''
  for [k, v] in items(s:syndic)
      if k ==? l:ft
          let l:cmd = v | break
      endif
  endfor
  if '' == l:cmd
      let l:cmd = input('cannot recognize this filetype, choose executor: ')
      let s:syndic[&filetype] = l:cmd
  endif
  return l:cmd
endfunction

function! rv#changerunscript(cmd)
  if '' == a:cmd
      echo s:syndic[&filetype]
  else
      let s:syndic[&filetype] = a:cmd
  endif
endfunction

" open new term and return buf number
function! s:newterm(executable)
  if has('nvim')
    new
    call termopen(a:executable)
    " termopen return jobid instead of buf_number, find it ugly
    let l:last_buf = bufnr('$')
    let l:i = 1
    while l:i <= l:last_buf
        if getbufvar(l:i, "&bt") == "terminal"
            let l:termbuf_id = l:i
            break
        endif
        let l:i = l:i + 1
    endwhile
  else
    let l:termbuf_id = term_start(a:executable)
  endif
  return l:termbuf_id
endfunction

" first time, create a repl. after that toggle or close
function! rv#replConnect(vm)
  let l:scheme_executable = a:vm
  if '' == l:scheme_executable
    let l:scheme_executable = s:chooseExecutor()
  endif
  if '' == l:scheme_executable
    return
  endif

  if !exists('s:repl_term_id') || ''==bufname(s:repl_term_id)
    let s:repl_term_id = s:newterm(l:scheme_executable)
    silent execute "resize " . s:term_height
    normal! G
  else
    let l:wid = bufwinnr(s:repl_term_id)
    if l:wid < 0
      exec "rightbelow ".s:term_height."split"
      exec "b".s:repl_term_id
    else
      exec l:wid."wincmd w"
      close
    endif
  endif
endfunction

" run part code in another window by cp<textobj>
function! rv#replEval(type)
  let sel_save = &selection
  let &selection = "inclusive"
  let reg_save = @@@@

  if a:0
    silent exe "normal! `<" . a:type . "`>y"
  elseif a:type == 'line'
    silent exe "normal! '[V']y"
  elseif a:type == 'block'
    silent exe "normal! `[\<C-V>`]y"
  else
    silent exe "normal! `[v`]y"
  endif

  if !exists('s:repl_term_id')
    call rv#replConnect('')
  end

  if has("nvim")
    call jobsend(s:repl_term_id, @@@@ . "\n")
  else
    call term_sendkeys(s:repl_term_id, @@@@ . "\n")
  end

  let &selection = sel_save
  let @@@@ = reg_save
endfunction

function! rv#runcurrentscript(hasarg)
  let l:cmd = s:chooseExecutor()
  if '' == l:cmd
      return
  endif
  let l:arg = ''
  if a:hasarg
    let l:arg = input('Arguments: ')
  endif
  execute 'write'
  call <SID>runcmd(l:cmd.' % '.l:arg)
endfunction

function! rv#runShellCommand(cmdline)
    silent execute "botright ".s:term_height."new"

    setlocal buftype=nofile
    setlocal bufhidden=delete
    setlocal nobuflisted
    setlocal noswapfile
    setlocal nowrap
    setlocal filetype=shell
    setlocal syntax=shell

    call setline(1, a:cmdline)
    call setline(2, substitute(a:cmdline, '.', '=', 'g'))
    execute 'silent $read !' . escape(a:cmdline, '%#')
    setlocal nomodifiable
    1
endfunction

function! rv#enhancegrep(useinput)
  let l:word = expand("<cword>")
  if type(a:useinput) == 1
      let l:word = a:useinput
  elseif a:useinput == 1
      let l:word = input("Keyword:")
  endif
  if executable('rg')
      call <SID>runcmd('rg "'.l:word.'"')
  elseif executable('ag')
      call <SID>runcmd('ag "'.l:word.'"')
  elseif executable('ack')
      call <SID>runcmd('ack "'.l:word.'"')
  else
      call <SID>runcmd('grep -i -R "'.l:word.'" *')
  endif
endfunction

" c-confirm    g-direct
function! rv#txtReplace(flag)
  let pat = input("Patern:")
  let tar = input("Target:")
  execute "%s/".pat."/".tar."/".a:flag
endfunction

" execute command another window and cursor stay
function! rv#openpreview(cmd)
  let cur_winid = winnr()
  if !exists('s:hint_buf_id')
    silent execute "botright ".s:hint_height."new"
    setlocal buftype=nofile
    setlocal nobuflisted
    let s:hint_buf_id = winbufnr(0)
  else
    let l:wid = bufwinnr(s:hint_buf_id)
    if l:wid < 0
      exec "rightbelow ".s:hint_height."split"
      exec "b".s:hint_buf_id
    else
      exec l:wid."wincmd w"
    endif
  endif
  " collect output of command and paste
  %d
  let out_cmd = system(a:cmd)
  put=l:out_cmd
  normal ggdd
  " Final goback orig window
  exec l:cur_winid."wincmd w"
endfunction

function! rv#closepreview()
  let l:wid = bufwinnr(s:hint_buf_id)
  if l:wid >= 0
    exec l:wid."wincmd w"
    close
  endif
endfunction

function! rv#showhint()
  let l:kw = input('HintWord: ')
  if l:kw != ''
    let l:ft = &filetype
    call rv#openpreview("snip ".l:ft." lib|grep ".l:kw)
  else
    call rv#closepreview()
  endif
endfunction
" }

" Toggle {
function! rv#togglequickfix()
  if MvcfCheckQuickfix()
      execute 'cclose'
  else
      execute 'copen'
  endif
endfunction

function! rv#toggleBG()
    let l:tbg = &background
    " Inversion
    if l:tbg == "dark"
        set background=light
    else
        set background=dark
    endif
endfunction

" Change between relativenumber and nonumber
function! rv#toggleNumber()
    let l:tbg = &relativenumber
    " Inversion
    if l:tbg == 1
        set norelativenumber
        set nonumber
    else
        set number
        set relativenumber
    endif
endfunction
" }

" Find top dir and refresh tags {
function! rv#gototopdir()
   let i = 1
   while i < 10
      if filereadable("tags") || isdirectory(".git")
        echo "Found top dir"
        return
      else
        lcd ..
        let i += 1
      endif
   endwhile
endfunction

function! rv#refreshtags()
   wall
   let l:Curr_dir=getcwd()
   let i = 1
   while i < 10
      if filereadable("tags")
        call <SID>runcmd('ctags -R', 'silent')
        "--fields=+lS  cscope -Rbkq
        return
      else
        lcd ..
        let i += 1
      endif
   endwhile
   exec 'cd '.l:Curr_dir
   "force buffer reload tags
   edit %
endfunction
" }

" Easy show {
function! rv#showMaps()
  let old_reg = getreg("a")          " save the current content of register a
  let old_reg_type = getregtype("a") " save the type of the register as well
try
  redir @@a                           " redirect output to register a
  " Get the list of all key mappings silently, satisfy "Press ENTER to continue"
  silent map  | call feedkeys("\<CR>")
  silent imap | call feedkeys("\<CR>")
  redir END                          " end output redirection
  vnew                               " new buffer in vertical window
  setlocal buftype=nofile
  setlocal bufhidden=delete
  setlocal nobuflisted
  setlocal noswapfile
  setlocal nowrap
  put a                              " put content of register
  " Sort on 4th character column which is the key(s)
  %!sort -k1.4,1.4
finally                              " Execute even if exception is raised
  call setreg("a", old_reg, old_reg_type) " restore register a
endtry
endfunction

function! rv#showEx(cmd)
  redir => message
  silent execute a:cmd
  redir END
  if empty(message)
    echoerr "no output"
  else
    " use "new" instead of "tabnew" below if you prefer split windows instead of tabs
    new
    setlocal buftype=nofile bufhidden=wipe noswapfile nobuflisted nomodified
    silent put=message
  endif
endfunction

" Snip in normal and insert mode
function! rv#showsnipcode()
    let l:ft = &filetype
    let l:arg = input('SnipKey: ')
    call rv#runShellCommand('snip '.l:ft.' '.l:arg)
endfunction

function! rv#inssnipcode()
  let l:a = input("SnipKey: ")
  if "" == l:a
    echo &filetype." support:"
    let l:ret = system('snip ! '.&filetype)
    echo split(l:ret, "\n")
    return
  endif
  "mark and paste, back and join line
  normal mq
  execute "put =system('snip ! ".&filetype." ".l:a."')"
  normal 'qJ
  "call feedkeys("i")
  "return ''
endfunction

function! rv#openfileinwin1()
  let pth = expand('<cfile>')
  1wincmd w
  execute 'e./'.pth
endfunction

" When not know what happen under vim, use this
function! rv#debug(...)
  let tname = ['int', 'str', 'fn', 'list', 'dict', 'bool', 'none', 'job', 'ch', 'blob']
  let logfile = 'rvdebug.log'
  "let l:cmd = printf("echo '>> stack:%s'>>%s", expand('<stack>'), logfile)
  "call system(l:cmd)
  let i = 1
  for v in a:000
    let l:nam = tname[type(v)]
    let l:cmd = printf("echo '>> arg%d:%s:%s'>>%s", i, l:nam, v, logfile)
    call system(l:cmd)
    let i = i+1
  endfor
endfunction
" }

@


1.27
log
@add preview like shell in vim
@
text
@d176 2
a177 1
function! rv#openhint(kw)
d195 1
a195 1
  let out_cmd = system(a:kw)
d202 1
a202 1
function! rv#closehint()
d209 10
@


1.26
log
@simple replace for vim
@
text
@d4 1
d175 33
@


1.25
log
@change scm engine to fennel and add Chrun doc
@
text
@d168 6
@


1.24
log
@adapt typename in nvim
@
text
@a0 1
" Modeline and Notes {
d2 1
a2 2
" }
let s:syndic = {'python':'python3', 'sh':'bash', 'lua':'lua', 'scheme':'stklos', 'lisp':'ecl'}
@


1.23
log
@use beauty method to choose terminal buf in nvim
@
text
@d308 1
d314 2
a315 1
    let l:cmd = printf("echo '>> arg%d:%s:%s'>>%s", i, type(v), v, logfile)
@


1.22
log
@make newterm work in nvim
@
text
@d53 1
a53 1
        if match(bufname(l:i), "term://") == 0
@


1.21
log
@seems nvim not work with AsyncRun, workaround it
@
text
@d44 1
d48 11
a58 1
    let l:term_id = termopen(a:executable)
d60 1
a60 1
    let l:term_id = term_start(a:executable)
d62 1
a62 1
  return l:term_id
d309 2
a310 2
  let cmd = printf("echo '>> stack:%s'>>%s", expand('<stack>'), logfile)
  call system(l:cmd)
d313 1
a313 1
    let cmd = printf("echo '>> arg%d:%s:%s'>>%s", i, typename(v), v, logfile)
@


1.20
log
@rv#debug output to file
@
text
@d11 3
a13 1
  if v:version >= 800
a17 2
  else
      execute 'Shell '.a:cmd
@


1.19
log
@improve vim rv#debug use echom
@
text
@d297 3
a299 1
  echom printf('>> stack:%s', expand('<stack>'))
d302 2
a303 1
    echom printf('>> arg%d:%s:%s', i, typename(v), v)
a305 3
  if input("press enter to continue") == "dummy"
      echo ''
  endif
@


1.18
log
@improve insert snip
@
text
@d235 1
a235 1
  silent map | call feedkeys("\<CR>")
d297 9
a305 9
    if winnr('$') == 1
        top new
        setlocal buftype=nofile
        setlocal bufhidden=delete
        setlocal nobuflisted
        setlocal noswapfile
    endif
    1wincmd w
    put=a:000
@


1.17
log
@add insert snipcode
@
text
@d281 2
d284 1
@


1.16
log
@make rv.vim uint and clear
@
text
@d266 1
d269 1
a269 1
    let l:arg = input('Keyword: ')
d273 13
@


1.15
log
@add Chrun command show and change runscript
@
text
@a79 1

d110 8
a117 28
function! rv#showMaps()
  let old_reg = getreg("a")          " save the current content of register a
  let old_reg_type = getregtype("a") " save the type of the register as well
try
  redir @@a                           " redirect output to register a
  " Get the list of all key mappings silently, satisfy "Press ENTER to continue"
  silent map | call feedkeys("\<CR>")
  silent imap | call feedkeys("\<CR>")
  redir END                          " end output redirection
  vnew                               " new buffer in vertical window
  setlocal buftype=nofile
  setlocal bufhidden=delete
  setlocal nobuflisted
  setlocal noswapfile
  setlocal nowrap
  put a                              " put content of register
  " Sort on 4th character column which is the key(s)
  %!sort -k1.4,1.4
finally                              " Execute even if exception is raised
  call setreg("a", old_reg, old_reg_type) " restore register a
endtry
endfunction

function! rv#togglequickfix()
  if MvcfCheckQuickfix()
      execute 'cclose'
  else
      execute 'copen'
d119 2
d141 27
a167 4
function! rv#showsnipcode()
    let l:ft = &filetype
    let l:arg = input('Keyword: ')
    call rv#runShellCommand('snip '.l:ft.' '.l:arg)
d192 15
a207 1
" refreshtags at top dir
d226 1
d228 22
a249 50
function! rv#runcurrentscript(hasarg)
  let l:cmd = s:chooseExecutor()
  if '' == l:cmd
      return
  endif
  let l:arg = ''
  if a:hasarg
    let l:arg = input('Arguments: ')
  endif
  execute 'write'
  call <SID>runcmd(l:cmd.' % '.l:arg)
endfunction

function! rv#openfileinwin1()
  let pth = expand('<cfile>')
  1wincmd w
  execute 'e./'.pth
endfunction

" Search-File-Keyword {
function! rv#enhancegrep(useinput)
  let l:word = expand("<cword>")
  if type(a:useinput) == 1
      let l:word = a:useinput
  elseif a:useinput == 1
      let l:word = input("Keyword:")
  endif
  if executable('rg')
      call <SID>runcmd('rg "'.l:word.'"')
  elseif executable('ag')
      call <SID>runcmd('ag "'.l:word.'"')
  elseif executable('ack')
      call <SID>runcmd('ack "'.l:word.'"')
  else
      call <SID>runcmd('grep -i -R "'.l:word.'" *')
  endif
endfunction

" find top dir
function! rv#gototopdir()
   let i = 1
   while i < 10
      if filereadable("tags") || isdirectory(".git")
        echo "Found top dir"
        return
      else
        lcd ..
        let i += 1
      endif
   endwhile
d266 12
a289 1

@


1.14
log
@make choose executor also avalble in repl
@
text
@d36 8
@


1.13
log
@add executor when filetype not recognize
@
text
@d29 4
d204 1
a204 2
      let l:cmd = input('cannot recognize this filetype, choose executor: ')
      let s:syndic[&filetype] = l:cmd
@


1.12
log
@fix cant open terminal when last time closed
@
text
@d200 2
a201 2
      echo 'runscript cannot recognize this filetype!'
      return
@


1.11
log
@enrich replConnect has create/open/close
@
text
@d52 1
a52 1
  if !exists('s:repl_term_id')
@


1.10
log
@use replConnect instead of vim-terminal-help
@
text
@d32 11
d52 13
a64 5
  if has('nvim')
    new
    let s:repl_term_id = termopen(l:scheme_executable)
  else
    let s:repl_term_id = term_start(l:scheme_executable)
a65 4

  silent execute "resize " . s:term_height

  normal! G
@


1.9
log
@minor improve config for vim
@
text
@d32 1
a32 1
function! s:replConnect(vm)
a52 1
command! -nargs=+ Repl call s:replConnect(<q-args>)
d71 1
a71 1
    call s:replConnect('')
@


1.8
log
@fixed bug:call replConnect miss let
@
text
@d2 1
a2 1
" vim: set sw=4 ts=4 sts=4 et tw=78 foldmarker={,} foldlevel=0 foldmethod=marker :
d5 1
d48 1
a48 4
  let g:scheme_split_size = get(g:, "scheme_split_size", "default")
  if g:scheme_split_size != "default"
    silent execute "resize " . g:scheme_split_size
  endif
d117 1
a117 1
    botright 10new
@


1.7
log
@let repl has parameter for specify
@
text
@d34 1
a34 1
    l:scheme_executable = s:chooseExecutor()
d55 1
a55 4
function! VMRun()
    let l:arg = input('Keyword: ')
    call s:replConnect(l:arg)
endfunction
@


1.6
log
@make Shell cmd 10height
@
text
@d31 2
a32 2
function! s:replConnect()
  let l:scheme_executable = s:chooseExecutor()
d34 4
a37 1
      return
d55 5
d77 1
a77 1
    call s:replConnect()
@


1.5
log
@restore sh execute in vim
@
text
@d114 1
a114 1
    botright new
@


1.4
log
@fix scheme cant use cp to compile
@
text
@d4 1
a4 1
let s:syndic = {'python':'python3', 'lua':'lua', 'scheme':'stklos', 'lisp':'ecl'}
@


1.3
log
@add vim debug function
@
text
@d4 1
a4 2
let s:syndic = {'python':'python3', 'sh':'bash', 'lua':'lua', 'scheme':'stklos', 'lisp':'ecl'}
autocmd FileType scheme,lisp,lua,python nnoremap <buffer> cp :set opfunc=<SID>replEval<cr>g@@
d53 1
a53 1
function! s:replEval(type)
@


1.2
log
@add showEx cmd for capture output of ex-mode
@
text
@d247 14
@


1.1
log
@use autoload instead of plugin
@
text
@d233 14
@

