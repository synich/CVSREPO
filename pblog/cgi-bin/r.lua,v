head	1.12;
access;
symbols;
locks; strict;
comment	@# @;


1.12
date	2022.11.07.16.24.43;	author alarm;	state Exp;
branches;
next	1.11;

1.11
date	2022.11.07.15.27.11;	author u0_a111;	state Exp;
branches;
next	1.10;
commitid	100636923CF5477DB30;

1.10
date	2022.11.01.16.09.42;	author u0_a111;	state Exp;
branches;
next	1.9;
commitid	100636144C653E484F2;

1.9
date	2022.10.07.16.35.57;	author u0_a111;	state Exp;
branches;
next	1.8;
commitid	1006340556D390C1B79;

1.8
date	2022.10.07.16.11.54;	author u0_a111;	state Exp;
branches;
next	1.7;
commitid	10063404FCA37244B29;

1.7
date	2022.10.03.09.42.04;	author u0_a111;	state Exp;
branches;
next	1.6;
commitid	100633AAE6C319048A0;

1.6
date	2022.10.02.14.21.38;	author u0_a111;	state Exp;
branches;
next	1.5;
commitid	10063399E721FE59B39;

1.5
date	2022.09.30.14.13.14;	author u0_a111;	state Exp;
branches;
next	1.4;
commitid	1006336F97A767E92AA;

1.4
date	2022.09.29.16.05.29;	author u0_a111;	state Exp;
branches;
next	1.3;
commitid	1006335C24907B4E42E;

1.3
date	2022.08.27.05.45.47;	author games;	state Exp;
branches;
next	1.2;
commitid	1006309AF8B5BE0651F;

1.2
date	2022.08.19.16.31.40;	author games;	state Exp;
branches;
next	1.1;
commitid	10062FFBAEC59C90F26;

1.1
date	2022.08.15.16.18.54;	author games;	state Exp;
branches;
next	;
commitid	10062FA71ED25C91C6F;


desc
@@


1.12
log
@query blog use sqlite
@
text
@#!/usr/bin/env lua
-- USAGE: provide xx.lua, must has cgi method as entry
-- cgi will get 3 table, first `p: {do}` is router
-- when query /xx.cgi/sth?arg=1, sth will get 2 table
-- q: {arg=1}(exclude ?)
-- c: {a=1,b=2}(urlencoed)


-------------------------------
-- handy function for write cgi
-------------------------------
-- format/template string
local function format(body, hole, ...)
  local lst = {...}
  if hole == "$" then hole = "%$" end
  for i=1,#lst do
    body = body:gsub(hole, lst[i], 1)
  end
  return body
end

-- easy wrap for io.popen
local function popen(cmd)
  cmd = cmd:gsub("`", "\\`") -- avoid ` work in shell
  local fd = io.popen(cmd)
  local txt = fd:read("*a")
  fd:close()
  return txt:sub(1, -2)  -- last is \n, drop it
end

local function str_split(s, delim)
  local t = {}
  local p_start, p_next = 1, 1
  local s_sec, p_eq = "", 1
  repeat
    p_next = s:find(delim, p_start, true)
    if p_next then
      s_sec = s:sub(p_start, p_next-1)
      p_start = p_next + 1
    else
      s_sec = s:sub(p_start)
    end
    table.insert(t, s_sec)
  until not p_next
  return t
end

local function sql_exec(db, sql_stmt)
  -- make write SQL literal, ugly but only this way
  sql_stmt = sql_stmt:gsub("%%", "%%%%")
  local cmd = format([[sqlite3 $.db "$"]], "$", db, sql_stmt)
  return popen(cmd)
end

local function errlog(msg)
  os.execute("echo "..'"`date` '..msg..'">>cgi-err.log')
end

-- character table string
local b='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'

-- encoding
local function b64enc(data)
    return ((data:gsub('.', function(x) 
        local r,b='',x:byte()
        for i=8,1,-1 do r=r..(b%2^i-b%2^(i-1)>0 and '1' or '0') end
        return r;
    end)..'0000'):gsub('%d%d%d?%d?%d?%d?', function(x)
        if (#x < 6) then return '' end
        local c=0
        for i=1,6 do c=c+(x:sub(i,i)=='1' and 2^(6-i) or 0) end
        return b:sub(c+1,c+1)
    end)..({ '', '==', '=' })[#data%3+1])
end

-- decoding
local function b64dec(data)
    data = string.gsub(data, '[^'..b..'=]', '')
    return (data:gsub('.', function(x)
        if (x == '=') then return '' end
        local r,f='',(b:find(x)-1)
        for i=6,1,-1 do r=r..(f%2^i-f%2^(i-1)>0 and '1' or '0') end
        return r;
    end):gsub('%d%d%d?%d?%d?%d?%d?%d?', function(x)
        if (#x ~= 8) then return '' end
        local c=0
        for i=1,8 do c=c+(x:sub(i,i)=='1' and 2^(8-i) or 0) end
        return string.char(c)
    end))
end


---------------------------
-- construct for http parse
---------------------------
local function _url_str_tbl(s)
  -- split urlencoed into table
  local t = {}
  local p_start, p_next = 1, 1
  local s_sec, p_eq = "", 1
  repeat
    p_next = s:find("&", p_start, true)
    if p_next then
      s_sec = s:sub(p_start, p_next-1)
      p_start = p_next + 1
    else
      s_sec = s:sub(p_start)
    end
    p_eq = s_sec:find("=", 1, true)
    if p_eq then
      t[s_sec:sub(1, p_eq-1)] = s_sec:sub(p_eq+1)
    end
  until not p_next
  return t
end

local function _path_tbl(s)
  local t = {}
  local p_start, p_next = 2, 1
  repeat
    p_next = s:find("/", p_start, true)
    if p_next then
      table.insert(t, s:sub(p_start, p_next-1))
      p_start = p_next + 1
    else
      table.insert(t, s:sub(p_start))
    end
  until not p_next
  return t
end

-- base64 in body will change by urlencoded, restore it
local function _res_urlenc(str)
  str = str:gsub("%%2B", "+")
  str = str:gsub("%%2F", "/")
  return str
end

local function main()
  -- part after r.cgi, e.g r.cgi/foo/bar, path_info is /foo/bar
  local path_info = os.getenv("PATH_INFO")
  -- part after ?(exclude ?), e.g r.cgi/foo?arg=3, query is arg=3
  local query_str = os.getenv("QUERY_STRING")
  local urlencoded_content = io.read("a")
  -- ensure html render
  print("Content-Type: text/html; charset=UTF-8\n")
  -- cal module's cgi function, urlencoded will make +/ to %2B%2F, restore them
  if nil then errlog(path_info..":"..query_str..":"..urlencoded_content) end
  cgi(_path_tbl(path_info),
      _url_str_tbl( _res_urlenc(query_str) ),
      _url_str_tbl( _res_urlenc(urlencoded_content) ))
end


---------------------------------------
-- cgi entry, register bussness into fn
---------------------------------------
local fn = {}
cgi = function(p,q,c)
    local ptf = fn[p[1]]
    if ptf then
      isok, msg = pcall(ptf, q, c)
      if not isok then errlog(p[1]..": "..msg) end
    else
      errlog("not found ["..p[1].."] request")
    end
end


@


1.11
log
@str_split
@
text
@d49 2
@


1.10
log
@guard and local
@
text
@d31 17
@


1.9
log
@make cgi template clarity
@
text
@d2 5
a6 5
--USAGE: provide xx.lua when query /xx.cgi/do?arg=1
--       must has cgi method, which will get 3 table
--       p: {do}
--       q: {arg=1}(exclude ?)
--       c: {a=1,b=2}(urlencoed)
d13 1
a13 1
function format(body, hole, ...)
d23 2
a24 1
function popen(cmd)
d31 5
@


1.8
log
@lua format string function
@
text
@d9 3
a11 38
local function _url_str_tbl(s)
  -- split urlencoed into table
  local t = {}
  local p_start, p_next = 1, 1
  local s_sec, p_eq = "", 1
  repeat
    p_next = s:find("&", p_start, true)
    if p_next then
      s_sec = s:sub(p_start, p_next-1)
      p_start = p_next + 1
    else
      s_sec = s:sub(p_start)
    end
    p_eq = s_sec:find("=", 1, true)
    if p_eq then
      t[s_sec:sub(1, p_eq-1)] = s_sec:sub(p_eq+1)
    end
  until not p_next
  return t
end


local function _path_tbl(s)
  local t = {}
  local p_start, p_next = 2, 1
  repeat
    p_next = s:find("/", p_start, true)
    if p_next then
      table.insert(t, s:sub(p_start, p_next-1))
      p_start = p_next + 1
    else
      table.insert(t, s:sub(p_start))
    end
  until not p_next
  return t
end


d22 8
d67 33
a99 7
-- cgi entry, register bussness into fn
local fn = {}
cgi = function(p,q,c)
    local ptf = fn[p[1]]
    if ptf then
      isok, msg = pcall(ptf, q, c)
      if not isok then errlog(p[1]..": "..msg) end
d101 1
a101 1
      errlog("not found ["..p[1].."] request")
d103 2
a113 1

d129 16
@


1.7
log
@edit blog
@
text
@d47 10
a60 7
-- base64 in body will change by urlencoded, restore it
local function res_urlenc(str)
  str = str:gsub("%%2B", "+")
  str = str:gsub("%%2F", "/")
  return str
end

d106 7
d125 2
a126 2
      _url_str_tbl( res_urlenc(query_str) ),
      _url_str_tbl( res_urlenc(urlencoded_content) ))
@


1.6
log
@blog show recent
@
text
@d113 1
@


1.5
log
@restore urlencode in entry
@
text
@d96 2
a97 1
      ptf(q,c)
@


1.4
log
@base64 and urlencdec for lua
@
text
@d111 1
a111 1
  -- cal module's cgi function
d113 2
a114 2
      _url_str_tbl(query_str),
      _url_str_tbl(urlencoded_content))
@


1.3
log
@move cgi template into r.lua
@
text
@d51 39
@


1.2
log
@cgi-bin errlog and utf8
@
text
@d52 12
@


1.1
log
@cgi-bin r.template -> r.lua
@
text
@d47 5
d59 1
a59 1
  print("Content-Type: text/html\n")
@

